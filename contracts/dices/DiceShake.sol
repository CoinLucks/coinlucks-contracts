// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

// Interfaces
import "../interfaces/IReferral.sol";
import "../interfaces/IVRF.sol";
import "../interfaces/IRedeem.sol";
import "../abstracts/BaseBetGame.sol";

/// @title DiceShake (instant on-chain game)
/// @author CoinLucks
/// @notice It consumes VRF
/// @dev DiceShake is a innovative cryptocurrency game.
/// Players can win crypto rewards by betting on the outcome of a 100-sided dice roll.
/// Multiple Betting Modes (Single number, Range, Odd/Even bet).
/// Features
/// 1) Jackpot Pool: Win by drawing number 42/69 to hit the jackpotPool prize.
/// 2) Win Streak Bonus: Win 5 times in a row to receive an extra payout of 5x betAmount.
/// 3) Loss Streak Bonus: Lose 5 times in a row to receive a payout of 1x betAmount.
contract DiceShake is BaseBetGame {
    enum BetType {
        SINGLE,
        RANGE,
        ODD,
        EVEN
    }

    struct BetExt {
        BetType betType;
        uint256 betNumber;
        uint256 rangeEnd;
        uint256 multiplier;
        bool isOver;
    }

    mapping(uint256 => BetExt) public betExts; // Store every user betExt

    // ======== Constructor =========

    constructor(
        uint256 _fee,
        uint256 _jackpotRate,
        uint256 _streakRate,
        uint256 _minBet,
        uint256 _maxBet
    ) BaseBetGame(_fee, _jackpotRate, _streakRate, _minBet, _maxBet) {
        settings.baseWinStreak = 4; // 4x
    }

    //  ============ Public functions  ============

    /// @notice Place bet
    /// @param betType: bet Type
    /// @param betAmount: bet amount
    /// @param betNumber: Number start to bet
    /// @param rangeEnd: Number end to bet
    /// @param isOver: bet over or under betNumber
    /// @param player: Address of player, optional (you can bet for someone else)
    /// @param ref: Address of referrer, optional
    /// @param note: Remark, optional
    /// @dev Instant cashback for referrals at the time of payment
    function placeBet(
        BetType betType,
        uint256 betAmount,
        uint256 betNumber,
        uint256 rangeEnd,
        bool isOver,
        address player,
        address ref,
        string calldata note
    ) external payable nonReentrant {
        require(betNumber >= 1 && betNumber <= 100, "Bet number must be between 1 and 100");
        if (betType == BetType.RANGE) {
            require(rangeEnd >= betNumber && rangeEnd <= 100, "Range end must be between bet number and 100");
            require(rangeEnd - betNumber >= 29 && rangeEnd - betNumber < 70, "Range limit");
        }
        if (player == address(0)) {
            player = msg.sender;
        }
        _placeBet(betAmount, player, ref, note);

        uint256 betId = gameStats.currentId;
        uint256 multiplier = calculateMultiplier(betType, betNumber, rangeEnd, isOver);

        BetExt memory betExt = BetExt({betType: betType, betNumber: betNumber, rangeEnd: rangeEnd, multiplier: multiplier, isOver: isOver});
        betExts[betId] = betExt;

        emit BetPlaced(betId, player, betAmount, note);

        bool state = interfaces.VRF.reqRandomNumber(betId, 100, 1);
        require(state, "VRF request failed");
    }

    /// @notice The method that sets the winner and transfers funds and prize
    /// @param id Id of the bet.
    /// @dev Everyone can call this method when the random number is generated by VRF.
    /// Normality triggered by the VRF contract automatically
    function redeem(uint256 id) public override nonReentrant {
        uint32[] memory drawResults = interfaces.VRF.viewRandomResult(id);
        require(drawResults.length == 1, "Invalid draw numbers");

        uint32 drawResult = drawResults[0];
        require(drawResult > 0 && drawResult <= 100, "Invalid draw number");

        Bet storage bet = bets[id];
        BetExt storage betExt = betExts[id];
        require(bet.betStatus == BetStatus.Pending, "Already Redeem");

        address player = bet.player;
        uint256 payout = 0;
        uint256 jackpotAmt = 0;
        bool won = calculatePrize(drawResult, betExt.betType, betExt.betNumber, betExt.rangeEnd, betExt.isOver);

        (payout, jackpotAmt) = calculatePayout(won, bet.betAmount, betExt.multiplier, drawResult);

        redeemPrize(id, player, won, payout, jackpotAmt, drawResults);
    }

    function calculateMultiplier(BetType betType, uint256 betNumber, uint256 rangeEnd, bool isOver) public view returns (uint256) {
        unchecked {
            uint256 totalFee = settings.protocolFee + settings.jackpotRate + settings.streakRate;
            uint256 base = 100 * 10000;
            uint256 feeMultiplier = 10000 - totalFee;

            if (betType == BetType.SINGLE) {
                if (isOver) {
                    return ((base / betNumber) * feeMultiplier) / 10000;
                } else {
                    return ((base / (101 - betNumber)) * feeMultiplier) / 10000;
                }
            } else if (betType == BetType.RANGE) {
                return ((base / (rangeEnd - betNumber + 1)) * feeMultiplier) / 10000;
            } else if (betType == BetType.ODD || betType == BetType.EVEN) {
                return 2 * feeMultiplier;
            } else {
                return feeMultiplier;
            }
        }
    }

    function calculatePrize(uint32 drawResult, BetType betType, uint256 betNumber, uint256 rangeEnd, bool isOver) public pure returns (bool) {
        if (betType == BetType.SINGLE) {
            return (isOver && drawResult > betNumber) || (!isOver && drawResult < betNumber);
        }

        if (betType == BetType.RANGE) {
            return drawResult >= betNumber && drawResult <= rangeEnd;
        }

        if (betType == BetType.ODD) {
            return drawResult % 2 == 1;
        }

        if (betType == BetType.EVEN) {
            return drawResult % 2 == 0;
        }
        return false;
    }

    function calculatePayout(bool won, uint256 betAmount, uint256 multiplier, uint256 drawResult) internal view returns (uint256, uint256) {
        if (!won) {
            return (0, 0);
        }

        uint256 payout = (betAmount * multiplier) / 10000;
        uint256 jackpotAmt = 0;

        if (drawResult == 42 || drawResult == 69) {
            // chance 2%
            jackpotAmt = (gameStats.jackpotPool * settings.jackpotBonus) / 10000; // 30% of gameStats.jackpotPool
        }
        return (payout, jackpotAmt);
    }

    function calculateWinRate(uint256 betId) public view override returns (uint256) {
        BetExt storage betExt = betExts[betId];
        if (betExt.betType == BetType.SINGLE) {
            if (betExt.isOver) {
                return (100 - betExt.betNumber) * 10;
            } else {
                return (betExt.betNumber - 1) * 10;
            }
        } else if (betExt.betType == BetType.RANGE) {
            return (betExt.rangeEnd - betExt.betNumber + 1) * 10;
        } else if (betExt.betType == BetType.ODD || betExt.betType == BetType.EVEN) {
            return 500;
        }
        return 0;
    }

    function calculateStreakWinMultiplier(uint256 winRate) public view override returns (uint256) {
        return settings.baseWinStreak > 0 ? settings.baseWinStreak - (winRate * settings.winStreakSlope) / 1000 : 0;
    }
}
