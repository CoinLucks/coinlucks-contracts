// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

// OpenZeppelin contracts
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/interfaces/IERC165.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

// Raffle interfaces
import "../interfaces/IVRF.sol";
import "../interfaces/IReferral.sol";
import "../interfaces/IRaffle.sol";
import "../interfaces/IRedeem.sol";

import {AddressUtil} from "../libraries/AddressUtil.sol";

/// @title Raffle (single winner, fixed amount of NATIVE/ERC20/ERC721/ERC1155 as prize)
/// @author CoinLucks
/// @notice It consumes gameInfo.VRF v2 from Chainlink. It has the role
/// @dev It saves in an ordered array the player wallet and the current
/// tickets count. So buying tickets has a complexity of O(1)
/// For calculating the winner, from the huge random number generated by Chainlink
/// a normalized random is generated by using the module method, adding 1 to have
/// a random from 1 to ticketsCount.
/// So next step is to perform a binary search on the ordered array to get the
/// player O(log n)
/// Example:
/// 0 -> { 1, player1} as player1 buys 1 ticket
/// 1 -> {51, player2} as player2 buys 50 tickets
/// 2 -> {52, player3} as player3 buys 1 ticket
/// 3 -> {53, player4} as player4 buys 1 ticket
/// 4 -> {153, player5} as player5 buys 10000 tickets
/// So the setWinner method performs a binary search on that sorted array to get the upper bound.
/// If the random number generated is 150, the winner is player5. If the random number is 20, winner is player2
contract RaffleContract is IRaffle, IRedeem, ERC721Holder, ERC1155Holder, ReentrancyGuard, Ownable, Pausable {
    // ============ Public Mutable Storage ============

    // Storage vars
    mapping(uint256 => Raffle) public raffles; // Raffle basic infomation
    mapping(uint256 => Prize) public prizes;
    mapping(uint256 => Eligibility[]) public eligibilities;
    mapping(uint256 => Ticket[]) public tickets; // Every raffle has a sorted array of Ticket
    mapping(uint256 => mapping(address => UserState)) public userStates; // Store user state info for earch raffle

    // Settings
    mapping(address => bool) public addressVerify; // Addresses accepted (ERC20 / ERC721 / ERC1155 .etc) for Prize token, Eligibility token, .etc
    mapping(address => bool) public operators;

    GameInfo public gameInfo;
    FeeDistribution public feeDistribution;
    FeeAddress public feeAddress;

    // ======== Constructor =========

    constructor() Ownable(msg.sender) {
        operators[msg.sender] = true;

        gameInfo.protocolFee = 600; // 6%

        feeDistribution.staking = 4000; // 40%
        feeDistribution.referralLv1 = 2400; // 24%
        feeDistribution.referralLv2 = 100; // 1%
        feeDistribution.charity = 500; // 5%
        feeDistribution.platform = 3000; // 30%
    }

    //  ============ Modifiers  ============

    modifier onlyOperator() {
        require(operators[msg.sender], "Only operator");
        _;
    }

    //  ============ Public functions  ============

    /// @notice Creates a raffle
    /// @param hasFree enable free ticket
    /// @param endTime raffle endTime
    /// @param maxPerUser raffle maxPerUser
    /// @param price raffle price
    /// @param prize raffle prize
    /// @param eligibility raffle Eligibility (optional)
    /// @param note raffle description (optional)
    /// @return raffleId
    function create(
        bool hasFree,
        uint256 endTime,
        uint256 maxPerUser,
        uint256 price,
        Prize calldata prize,
        Eligibility[] calldata eligibility,
        string calldata note
    ) external payable nonReentrant whenNotPaused returns (uint256) {
        _validateCreation(endTime, maxPerUser, price, prize, note);

        gameInfo.currentId++;
        uint256 raffleId = gameInfo.currentId;

        // raffle
        Raffle storage raffle = raffles[raffleId];
        raffle.status = STATUS.OPEN;
        raffle.hasFree = hasFree;
        raffle.platformFee = gameInfo.protocolFee;
        raffle.endTime = endTime;
        raffle.maxPerUser = maxPerUser;
        raffle.price = price;
        raffle.seller = msg.sender;
        raffle.eligibility = eligibility.length;

        prizes[raffleId] = prize;

        // eligibility
        for (uint256 i = 0; i < eligibility.length; i++) {
            Eligibility memory eligib = eligibility[i];
            _validateEligibility(eligib);
            eligibilities[raffleId].push(eligib);
        }

        // transfer prize
        _depositPrize(prize);

        emit RaffleCreated(raffleId, msg.sender, endTime, note);

        return raffleId;
    }

    /// @notice Close the raffle
    /// @param raffleId Id of the raffle
    /// @dev It triggers gameInfo.VRF by Chainlink
    /// and generates a random number that is normalized and checked that corresponds to a CoinLucks player
    function close(uint256 raffleId) external nonReentrant {
        Raffle storage raffle = raffles[raffleId];
        require(raffle.status == STATUS.OPEN, "Not open");
        require(block.timestamp > raffle.endTime, "Not ended");

        if (raffle.amountRaised == 0 && raffle.ticketsCount == 0) {
            // cancel raffle
            require(raffle.seller == msg.sender, "Only seller");
            raffle.status = STATUS.CANCEL;
            _transferPrize(raffleId, raffle.seller); // claim prize
        } else {
            raffle.status = STATUS.CLOSE;
            require(address(gameInfo.VRF) != address(0), "gameInfo.VRF not set");
            bool state = gameInfo.VRF.reqRandomNumber(raffleId, raffle.ticketsCount, 1);
            require(state, "gameInfo.VRF request failed");
        }

        emit RaffleClosed(raffleId, msg.sender, raffle.amountRaised);
    }

    /// @notice The operator can cancel the raffle
    /// @param raffleId Id of the raffle
    /// @dev Can only be canceled if no one has ever buy a ticket. The prize will sent back to the seller
    function cancel(uint256 raffleId) external nonReentrant {
        Raffle storage raffle = raffles[raffleId];

        require(raffle.status == STATUS.OPEN, "Not open");
        require(raffle.seller == msg.sender || operators[msg.sender], "Only seller"); // only seller and operator
        require(raffle.amountRaised == 0 && raffle.ticketsCount == 0, "Tickets sold");

        raffle.status = STATUS.CANCEL;
        _transferPrize(raffleId, raffle.seller); // transfer prize to seller

        emit RaffleCancelled(raffleId, msg.sender, raffle.amountRaised);
    }

    /// @notice Buy raffle tickets
    /// @param raffleId: id of the raffle
    /// @param num: Number of tickets
    /// @param ref: Address of referrer, optional
    /// @param to: Ticket reciever, optional (you can buy a ticket to someone else)
    /// @param note: Remark, optional
    /// @dev Instant cashback for referrals at the time of payment
    function buy(uint256 raffleId, uint256 num, address ref, address to, string calldata note) external payable nonReentrant {
        address buyTo = to == address(0) ? msg.sender : to;
        Raffle storage raffle = raffles[raffleId];
        _validateBuy(raffleId, num, ref, buyTo, msg.value);
        // add a new element to the Ticket array, used to calc the winner
        uint256 ticketId = tickets[raffleId].length + 1;
        uint256 start = raffle.ticketsCount + 1;
        uint256 end = raffle.ticketsCount + num;
        Ticket memory ticket = Ticket({user: buyTo, id: ticketId, start: start, end: end});
        tickets[raffleId].push(ticket);
        unchecked {
            raffle.amountRaised += msg.value;
            raffle.amountCollected += msg.value;
            raffle.ticketsCount += num;
        }
        uint256 refFeeAmount = referralReward(raffleId, ref, msg.sender, msg.value);
        raffle.amountCollected -= refFeeAmount;
        emit BuyTicket(raffleId, buyTo, ticketId, num, raffle.ticketsCount, note);
    }

    function transferTickets(uint256 raffleId, address to, uint256[] calldata ids) public nonReentrant {
        Raffle storage raffle = raffles[raffleId];
        require(raffle.status == STATUS.OPEN, "Not open");
        require(block.timestamp <= raffle.endTime, "Expired");
        require(to != address(0) && to != msg.sender, "W to");

        for (uint256 i; i < ids.length; i++) {
            uint256 id = ids[i];
            Ticket storage ticket = tickets[raffleId][id - 1];
            require(ticket.user == msg.sender, "Not your tk");
            require(ticket.id == id, "W id");

            uint256 num = id == 1 ? ticket.end : (ticket.end - tickets[raffleId][id - 2].end);
            if (raffle.maxPerUser > 0) {
                require(userStates[raffleId][to].counts + num <= raffle.maxPerUser, "Exceeds maxPerUser");
            }

            userStates[raffleId][msg.sender].counts -= num;
            userStates[raffleId][to].counts += num;
            ticket.user = to;
        }

        emit TransferTickets(raffleId, msg.sender, to, ids);
    }

    /// @notice The method that sets the winner and transfers funds and prize
    /// @param id Id of the raffle.
    /// @dev Everyone can call this method when the random number is generated by gameInfo.VRF.
    /// Normality triggered by the gameInfo.VRF contract (RaffleVRF.sol) automatically
    function redeem(uint256 id) public nonReentrant {
        (address winner, uint32 finalNo) = checkAndFindWinner(id, 0);

        Raffle storage raffle = raffles[id];
        raffle.winner = winner;
        raffle.status = STATUS.END;
        raffle.randomNumber = finalNo;

        // transfer prize to winner
        _transferPrize(id, raffle.winner);

        // dispatch fees
        distributeFees(id, raffle.amountRaised - raffle.amountCollected);

        emit RaffleEnded(id, msg.sender, raffle.winner, raffle.amountRaised, raffle.ticketsCount, finalNo);
    }

    /// @notice Check the ticket and claim prize (save gas & incase of redeem() faild)
    /// @param id Id of the raffle.
    /// @param ticketId index of tickets.
    /// @dev Everyone can call this method when the findWinnerFromRandom sucks.
    function claimReward(uint256 id, uint256 ticketId) public nonReentrant {
        (address winner, uint32 finalNo) = checkAndFindWinner(id, ticketId);

        Raffle storage raffle = raffles[id];
        raffle.winner = winner;
        raffle.status = STATUS.END;
        raffle.randomNumber = finalNo;

        // transfer prize to winner
        _transferPrize(id, raffle.winner);

        // dispatch fees
        distributeFees(id, raffle.amountRaised - raffle.amountCollected);

        emit RaffleEnded(id, msg.sender, raffle.winner, raffle.amountRaised, raffle.ticketsCount, finalNo);
    }

    // ============ Public views ============

    /// Checking eligibility of a user
    function checkEligibility(uint256 raffleId, address user) public view returns (bool) {
        Eligibility[] storage egbs = eligibilities[raffleId];
        for (uint256 i = 0; i < egbs.length; i++) {
            _checkBalance(user, egbs[i].token, egbs[i].amount, egbs[i].tokenId);
        }
        return true;
    }

    // helper method to get the winner address of a raffle
    /// @param raffleId Id of the raffle
    /// @param _random Generated by chainlink
    /// @return the wallet that won the raffle
    /// @dev Uses a binary search on the sorted array to retreive the winner
    function findWinnerFromRandom(uint256 raffleId, uint256 _random) public view returns (address) {
        require(_random > 0, "Invalid random");
        require(tickets[raffleId].length > 0, "No tickets");
        uint256 position = findUpperBound(tickets[raffleId], _random);
        return tickets[raffleId][position].user;
    }

    function checkAndFindWinner(uint256 id, uint256 ticketId) internal returns (address, uint32) {
        Raffle storage raffle = raffles[id];
        require(raffle.status == STATUS.CLOSE, "Not close");
        require(address(gameInfo.VRF) != address(0), "gameInfo.VRF not set");

        // get drawn number from gameInfo.VRF
        uint32[] memory drawResults = gameInfo.VRF.viewRandomResult(id);
        require(drawResults.length == 1, "Invalid draw numbers");

        uint32 finalNo = gameInfo.VRF.viewRandomResult(id)[0];
        require(finalNo > 0 && finalNo <= raffle.ticketsCount, "Invalid random number");

        // find winner by drawn number
        if (ticketId == 0) {
            raffle.winner = findWinnerFromRandom(id, finalNo);
            require(raffle.winner != address(0), "Winner not found");
            return (raffle.winner, finalNo);
        } else {
            Ticket memory ticket = tickets[id][ticketId - 1];
            require(ticket.start >= finalNo && finalNo <= ticket.end, "Not winner");
            return (ticket.user, finalNo);
        }
    }

    function getWinNumber(uint256 raffleId) external view returns (uint32) {
        uint32[] memory drawResults = gameInfo.VRF.viewRandomResult(raffleId);
        return drawResults.length == 1 ? gameInfo.VRF.viewRandomResult(raffleId)[0] : 0;
    }

    function getReferrer(address user) external view returns (address, address, address) {
        return gameInfo.REFERRAL.getReferrer(user);
    }

    // ============ Internal functions ============

    /**
        staticcall balanceOf for safety check
     */
    function _checkBalance(address user, address addr, uint256 amount, uint256 tokenId) internal view returns (bool) {
        if (AddressUtil.isERC1155(addr)) {
            (bool success, bytes memory data) = addr.staticcall(abi.encodeWithSelector(IERC1155.balanceOf.selector, user, tokenId));
            require(success && abi.decode(data, (uint256)) >= amount, "Insufficient 1155");
        } else if (AddressUtil.isERC721(addr)) {
            (bool success, bytes memory data) = addr.staticcall(abi.encodeWithSelector(IERC721.balanceOf.selector, user));
            require(success && abi.decode(data, (uint256)) >= amount, "Insufficient 721");
        } else {
            (bool success, bytes memory data) = addr.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, user));
            require(success && abi.decode(data, (uint256)) >= amount, "Insufficient 20");
        }
        return true;
    }

    /// @param array sorted array of Ticket. end is the numeric field used to sort
    /// @param element uint256 to find. Goes from 1 to ticketsCount
    /// @dev based on openzeppelin code (v4.0), modified to use an array of Ticket
    /// Searches a sorted array and returns the first index that contains a value greater or equal to element.
    /// If no such index exists (i.e. all values in the array are strictly less than element), the array length is returned. Time complexity O(log n).
    /// array is expected to be sorted in ascending order, and to contain no repeated elements.
    /// https://docs.openzeppelin.com/contracts/3.x/api/utils#Arrays-findUpperBound-uint256---uint256-
    function findUpperBound(Ticket[] storage array, uint256 element) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);
            if (array[mid].end > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1].end == element) {
            return low - 1;
        } else {
            return low;
        }
    }

    function _validateCreation(uint256 endTime, uint256 maxPerUser, uint256 price, Prize calldata prize, string calldata note) internal view {
        require(endTime - block.timestamp > 180 && endTime - block.timestamp < 7776000, "W endTime"); // at least 3 min, 90 days max
        require(price > 0 || (price == 0 && maxPerUser == 1), "W price");
        require(bytes(note).length <= 500, "Note too long");

        _validatePrize(prize);
    }

    function _validatePrize(Prize calldata prize) internal view {
        require(prize.amount > 0, "W prize amt");
        if (prize.prizeType == PRIZE_TYPE.NATIVE) {
            require(msg.value == prize.amount, "W value");
        } else {
            require(prize.token != address(0) && addressVerify[prize.token], "Unlisted prize");
        }
        if (prize.prizeType == PRIZE_TYPE.TOKEN) {
            require(AddressUtil.isERC20(prize.token), "W token");
            require(IERC20(prize.token).balanceOf(msg.sender) >= prize.amount, "Insufficient balance");
            require(IERC20(prize.token).allowance(msg.sender, address(this)) >= prize.amount, "Insufficient allowance");
        }
        if (prize.prizeType == PRIZE_TYPE.NFT) {
            require(AddressUtil.isNFT(prize.token), "W nft");
            require(prize.tokenId > 0, "W tokenId");
        }
    }

    /// Validate when buying
    function _validateBuy(uint256 raffleId, uint256 num, address ref, address to, uint256 value) internal {
        Raffle storage raffle = raffles[raffleId];

        require(raffle.status == STATUS.OPEN, "Not open");
        require(block.timestamp <= raffle.endTime, "Expired");
        require(to != raffle.seller, "Not allow seller");

        // check inputs
        if (value == 0) {
            // check free ticket
            require(num == 1, "W num");
            require(raffle.hasFree, "No free tk");
            require(userStates[raffleId][to].gotFree == false, "Exceeds free tk");
            userStates[raffleId][to].gotFree = true;
        } else {
            // check price
            require(num * raffle.price == value, "Insufficient funds");
        }

        if (raffle.maxPerUser > 0) {
            require(userStates[raffleId][to].counts + num <= raffle.maxPerUser, "Exceeds maxPerUser");
        }
        userStates[raffleId][to].counts += num;

        // check referral
        require(ref == address(0) || (ref != msg.sender && !AddressUtil.isContract(ref)), "W ref");

        // check eligibility
        checkEligibility(raffleId, to);
    }

    /// Validate when creating raffle
    function _validateEligibility(Eligibility memory elg) internal view {
        require(elg.token != address(0), "Eligib zero addr");
        if (AddressUtil.isERC1155(elg.token)) {
            require(elg.tokenId > 0 && elg.amount > 0, "Eligib amt");
        } else if (AddressUtil.isERC721(elg.token) || AddressUtil.isERC20(elg.token)) {
            require(elg.amount > 0, "Eligib amt");
        } else {
            revert("Eligib token");
        }
    }

    function _depositPrize(Prize calldata prize) internal {
        if (prize.prizeType == PRIZE_TYPE.NATIVE) {
            require(msg.value == prize.amount, "W value");
        }
        if (prize.prizeType == PRIZE_TYPE.TOKEN) {
            IERC20(prize.token).transferFrom(msg.sender, address(this), prize.amount);
        }
        if (prize.prizeType == PRIZE_TYPE.NFT) {
            _transferNFT(prize.token, msg.sender, address(this), prize.tokenId, prize.amount);
        }
    }

    function _transferPrize(uint256 raffleId, address to) internal {
        Prize storage prize = prizes[raffleId];
        if (prize.prizeType == PRIZE_TYPE.NFT) {
            _transferNFT(prize.token, address(this), to, prize.tokenId, prize.amount);
        }

        if (prize.prizeType == PRIZE_TYPE.TOKEN) {
            IERC20(prize.token).transfer(to, prize.amount);
        }

        if (prize.prizeType == PRIZE_TYPE.NATIVE) {
            (bool success, ) = payable(to).call{value: prize.amount}("");
            require(success, "Native transfer failed");
        }

        emit TransferPrize(raffleId, to, prize);
    }

    function _transferNFT(address nft, address from, address to, uint256 tokenId, uint256 amount) internal {
        require(nft != from && from != to, "W address");
        if (AddressUtil.isERC721(nft)) {
            IERC721(nft).transferFrom(from, to, tokenId);
        } else if (AddressUtil.isERC1155(nft)) {
            IERC1155(nft).safeTransferFrom(from, to, tokenId, amount, "");
        } else {
            revert("Unsupport NFT");
        }
    }

    function referralReward(uint256 raffleId, address ref, address sender, uint256 value) internal returns (uint256) {
        uint256 fee = 0;
        if (address(gameInfo.REFERRAL) != address(0)) {
            // get relationship from referral contract
            (address referrer, address superior, address referree) = gameInfo.REFERRAL.getReferrer(sender);
            if (referrer == address(0) && referree == address(0) && ref != address(0)) {
                gameInfo.REFERRAL.setReferrer(sender, ref);
                // bind and get latest relationship
                (referrer, superior, ) = gameInfo.REFERRAL.getReferrer(sender);
            }
            // process shares
            Raffle storage raffle = raffles[raffleId];
            if (raffle.platformFee > 0 && value > 0) {
                uint256 feeAmt = (raffle.platformFee * value) / 10000;

                if (referrer != address(0) && feeDistribution.referralLv1 > 0) {
                    uint256 refAmount = (feeAmt * feeDistribution.referralLv1) / 10000;
                    fee += refAmount;
                    (bool success, ) = referrer.call{value: refAmount}("");
                    require(success, "Referral transfer failed");

                    emit ReferralReward(raffleId, sender, referrer, value, refAmount);
                }

                if (superior != address(0) && feeDistribution.referralLv2 > 0) {
                    uint256 refAmount = (feeAmt * feeDistribution.referralLv2) / 10000;
                    fee += refAmount;
                    (bool success, ) = referrer.call{value: refAmount}("");
                    require(success, "Referral superior transfer failed");

                    emit ReferralReward(raffleId, sender, superior, value, refAmount);
                }
            }
        }
        return fee;
    }

    function distributeFee(uint256 raffleId, address addr, uint256 amount) internal returns (bool) {
        if (addr != address(0)) {
            (bool success, ) = addr.call{value: amount}("");
            require(success, "Fee send failed");
            emit DistributeFee(raffleId, addr, amount);
            return true;
        }
        return false;
    }

    /// @notice transfer protocol fees to roles
    /// @param raffleId raffle id
    function distributeFees(uint256 raffleId, uint256 feeDistributed) internal {
        Raffle storage raffle = raffles[raffleId];
        uint256 amountRaised = raffle.amountRaised;
        uint256 totalFee = (amountRaised * raffle.platformFee) / 10000;

        // Calculate amount to seller
        uint256 sellerAmount = amountRaised - totalFee;

        // 1.  Calculate fee shares
        uint256 charityAmt = (totalFee * feeDistribution.charity) / 10000;
        uint256 stakingAmt = (totalFee * feeDistribution.staking) / 10000;
        totalFee -= feeDistributed;

        // 2. transfer funds
        {
            // charity
            if (totalFee >= charityAmt && distributeFee(raffleId, feeAddress.charity, charityAmt)) {
                totalFee -= charityAmt;
            }
            // staking
            if (totalFee >= stakingAmt && distributeFee(raffleId, feeAddress.staking, stakingAmt)) {
                totalFee -= stakingAmt;
            }
            // platform
            if (totalFee > 0) {
                distributeFee(raffleId, feeAddress.platform, totalFee);
            }
            // to seller
            if (sellerAmount > 0) {
                payable(raffle.seller).transfer(sellerAmount);
                emit TransferFund(raffleId, raffle.seller, sellerAmount);
            }
        }
    }

    //  ============ onlyOwner  functions  ============

    function setInterface(address _vrf, address ref) external onlyOwner {
        gameInfo.VRF = IVRF(_vrf);
        gameInfo.REFERRAL = IReferral(ref);
    }

    function setProtocolFee(uint256 _fee) external onlyOwner {
        require(_fee <= 5000, "W fee"); // max 50%
        gameInfo.protocolFee = _fee;
    }

    function setFeeDistribution(FeeDistribution calldata _fees) external onlyOwner {
        feeDistribution = _fees;
    }

    function setFeeAddress(FeeAddress calldata _addrs) external onlyOwner {
        feeAddress = _addrs;
    }

    function setVerifyAddress(address[] calldata _addrs, bool enable) external onlyOperator {
        for (uint256 i; i < _addrs.length; i++) {
            addressVerify[_addrs[i]] = enable;
        }
    }

    function setOperator(address _addr, bool _enable) external onlyOwner {
        require(_addr != address(0), "W addr");
        operators[_addr] = _enable;
    }

    /**
     * For emergency case
     */
    function withdraw(uint256 amount) external onlyOwner {
        payable(msg.sender).transfer(amount);
    }

    function Pause() external onlyOwner {
        _pause();
    }

    function Unpause() external onlyOwner {
        _unpause();
    }
}
